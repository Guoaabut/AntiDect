# PE 文件结构核心知识总结

本文档总结了Windows PE（Portable Executable）文件格式的核心概念，包括地址模型、文件结构、加载流程及其在网络安全（免杀）领域的应用。

## 1. 核心地址概念

PE文件的内存地址模型基于三个核心概念：ImageBase, RVA, 和 VA。

### ImageBase (镜像基地址)
- **定义**: PE文件期望被加载到的内存**起始地址**。这是一个“建议值”，记录在 `OptionalHeader` 中。
- **作用**: 如果此地址可用，Windows加载器会直接将文件映射到这里，效率最高。如果不可用（例如因为ASLR或地址冲突），加载器会为文件选择一个新的基地址，这个过程称为**重定位(Rebasing)**。

### RVA (Relative Virtual Address / 相对虚拟地址)
- **定义**: 相对于`ImageBase`的**偏移量**。PE文件内部的所有引用（如函数、数据位置）都使用RVA，使其代码地址无关。
- **作用**: 无论文件最终被加载到哪个`ImageBase`，其内部结构的相对位置永远不变。

### VA (Virtual Address / 虚拟地址)
- **定义**: 程序在内存中的**绝对地址**，是CPU执行指令时实际使用的地址。
- **作用**: `GetProcAddress` 等API返回的就是VA。

### 核心公式
这三者之间的关系可以用一个简单的公式表示：
```
VA = ImageBase + RVA
```

---

## 2. PE 文件整体结构

一个PE文件从上到下由以下几个部分组成：

```
+---------------------------+
|        DOS 头             | (IMAGE_DOS_HEADER)
+---------------------------+
|        DOS Stub           |
+---------------------------+
|        NT 头              | (IMAGE_NT_HEADERS)
+---------------------------+
|        节表 (目录)         | (Section Table)
+---------------------------+
|      节区 (实际内容)        | (.text, .data, etc.)
+---------------------------+
```

---

## 3. PE 结构详解

### 3.1. DOS 头 (IMAGE_DOS_HEADER)
- 为了兼容古老的MS-DOS系统。
- **`e_magic`**: 文件开头的 "MZ" (0x5A4D) 标志。
- **`e_lfanew`**: 一个极其重要的偏移量，指向核心的 **NT头**。

### 3.2. NT 头 (IMAGE_NT_HEADERS)
由 `e_lfanew` 指向，是PE文件的控制中心。

- **Signature**: "PE\0\0" (0x00004550) 签名，确认文件类型。
- **文件头 (File Header)**: 包含文件的基本信息。
  - `Machine`: 目标CPU架构 (x86, x64等)。
  - `NumberOfSections`: 文件中节的数量，决定了后面节表的大小。
  - `Characteristics`: 文件属性（EXE, DLL等）。
- **可选头 (Optional Header)**: 包含加载器所需的关键信息。
  - `AddressOfEntryPoint`: 程序入口点的RVA，CPU从这里开始执行。
  - `ImageBase`: 期望的加载基地址。
  - `SizeOfImage`: 文件加载到内存后占用的总空间。
  - `DataDirectory`: 一个包含16个条目的数组，是指向各种重要数据结构（如导入/导出表）的“快捷方式”列表。

### 3.3. 节表 (Section Table)
- 一个 `IMAGE_SECTION_HEADER` 结构体数组，作为PE文件中所有“节”的目录。
- 每个条目描述了一个节的：
  - `Name`: 节名，如 `.text`。
  - `VirtualAddress`: 节加载到内存后的RVA。
  - `PointerToRawData`: 节在文件中的偏移量。
  - `SizeOfRawData`: 节在文件中的大小。
  - `Characteristics`: 节的内存权限（读、写、执行）。

### 3.4. 节区 (Sections)
- PE文件的实际内容，存放代码和数据。
- **`.text`**: 可执行代码。
- **`.data`**: 初始化的全局/静态变量。
- **`.rdata`**: 只读数据，如字符串常量。
- **`.idata`**: 导入表，记录程序依赖的外部函数。
- **`.edata`**: 导出表，记录程序能提供的函数。
- **`.rsrc`**: 资源，如图标、菜单等。
- **`.reloc`**: 重定位信息，用于`ImageBase`发生变化时修复地址。

---

## 4. PE 加载流程

当运行一个EXE时，Windows加载器执行以下步骤：
1.  **创建进程**: 创建一个挂起的主线程和独立的虚拟地址空间。
2.  **文件映射**:
    - 读取PE头进行校验。
    - 根据`ImageBase`在虚拟地址空间中预留内存。
    - 按照**节表**的指示，将文件中的各个节区数据复制到内存中的正确位置。
3.  **加载依赖 (解析导入表)**:
    - 遍历程序的**导入表**，找到所有依赖的DLL。
    - 递归调用`LoadLibrary`加载这些DLL。
    - 获取导入函数的实际地址(VA)，并填充到主程序的**导入地址表(IAT)**中。
4.  **执行重定位**: 如果程序没能加载到首选`ImageBase`，则根据`.reloc`节中的信息修复所有硬编码的绝对地址。
5.  **设置内存保护**: 根据节表中的`Characteristics`，为每个内存节区设置正确的读/写/执行权限。
6.  **启动执行**: 恢复主线程，并将CPU的指令指针设置到程序的`AddressOfEntryPoint`，程序开始运行。

---

## 5. 与免杀技术的联系

以上知识是免杀技术的**核心基础**。免杀技术就是通过滥用、欺骗或绕过上述规则来躲避安全软件的检测。

- **手动PE加载 (Reflective DLL Injection)**: 在内存中手动模拟加载器的所有工作，以绕过`LoadLibrary`监控。
- **进程镂空 (Process Hollowing)**: 将正常进程的代码掏空，换成恶意代码，以达到伪装的目的。
- **API Unhooking**: 通过重写内存中被安全软件修改过的`.text`节，恢复API的原始功能，摆脱监控。
- **加壳 (Packers)**: 将原始PE加密，用一个“外壳”程序包裹起来，运行时再解密到内存中执行，以对抗静态分析。

掌握PE文件结构和加载原理，是理解和实现这些高级技术的关键。
